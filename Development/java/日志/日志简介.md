

2001年以前，Java是没有日志库的，打印日志全凭System.out和System.err

但是有很多缺点

- 产生大量的IO操作 同时在生产环境中 无法合理的控制是否需要输出
- 输出的内容不能保存到文件
- 只能打印到控制台，需要自己重定向
- 无法定制化，而且日志粒度不够细



**Log4j**: 2001年Ceki推出了Log4j

**JUL(Java Util Logging)**:2002年2月JDK1.4发布，Sun推出了自己的日志标准库JUL(Java Util Logging)，其实是照着Log4j抄的，而且还没抄好，还是在JDK1.5以后性能和可用性才有所提升。

**JCL(Jakarta Commons Logging):** 当时市面上有两款Java日志标准库，分别是Log4j和JUL，此时Apache想统一抽象日志标准接口规范(就像JDBC统一数据库访问层)，让其他日志标准库去实现它的抽象接口，这样我们的日志操作都是统一的接口。于是JUL刚出来不久，2002年8月Apache推出了JCL(Jakarta Commons Logging),也就是日志抽象层，支持运行时动态加载日志组件的实现，当然也提供一个默认实现Simple Log(在ClassLoader中进行查找，如果能找到Log4j则默认使用Log4j实现，如果没有则使用JUL实现，再没有则使用JCL内部提供的Simple Log实现)

但是JUL有很多缺点

1.效率较低

2.容易引发混乱

3.使用了自定义ClassLoader的程序中，使用JCL会引发内容泄漏



**Slf4j(Simple Logging Facade for Java):** 2006年Ceki(Log4j的作者)因为一些原因离开了Apache组织，之后Ceki觉得JCL不好用，自己写了一套新的日志标准接口规范Slf4j(Simple Logging Facade for Java)，也可以称之为日志门面，很明显Slf4j是对标JCL，后面也证明了Slf4j比JCL更优秀。 但是由于Slf4j出来的较晚，光有一个接口，没有实现的日志库，比如JUL和Log4j都没有实现Slf4j，后来Ceki提供了一系列的桥接包来帮助Slf4j接口与其他日志库建立关系。这种方式称之为桥接设计模式。



**Logback:**Ceki觉得市场上的日志标准库都是间接实现Slf4j接口，也就是说每次都需要配合桥接包，因此在2006年，Ceki基于Slf4j接口撸出了Logback日志标准库，作为Slf4j接口的默认实现，Logback也十分给力，在功能完成度和性能上超越了所有已有的日志标准库。



**Log4j2:** 自从Logback出来后，可以说Slf4j+Logback组合如日中天，很冲击JCL+Log4j组合，Apache眼看有被Logback反超的势头。

于是2012年，Apache直接推出新项目Log4j2(不兼容Log4j)，Log4j2全面借鉴Slf4j+Logback。因为Log4j2不仅仅具有Logback的所有特性，还做了分离设计，分为log4j-api和log4j-core，log4j-api是日志接口，log4j-core是日志标准库。





















