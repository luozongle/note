# 模板方法模式

[TOC]



## 模式方法定义:

定义一个操作的算法骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构的情况下，重定义该算法的某些特定步骤。



## 模板方法特点

模板方法模式就是通过把不变的行为搬移到超类，去除子类中的重复代码来体现它的优势

模板方法提供了一个很好的代码复用平台，因为有时候，我们会遇到一系列步骤构成的过程需要执行。这个过程从高层次上看是相同的，但是有些步骤的实现可能不同。这时候，我们通常就应该考虑模板方法模式了。

当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模板方法模式把这些行为搬移到单一的地方，这样就能帮助子类摆脱重复的不变行为的纠缠。



我们也可以有一个默认不做事或者默认做某事的方法，我们称这种方法为"hook"(钩子)，钩子是一种被声明在抽象类中的方法，但是有空的或默认的实现。钩子的存在可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，让子类自行决定。



## 注意事项

在写模板方法时，可以让算法内步骤不要切割的太细，否则在子类中实现会稍显麻烦，但是如果步骤太少，会比较没有弹性，所以要看情况折中。

如果某些步骤是可选的，可以将这些步骤实现成钩子，而不是实现成抽象方法，这样就可以让抽象类的子类负荷减轻。




## 应用场景:

1.当想让客户端只扩展算法的特定步骤，而不是整个算法或其数据结构时，可以使用Template Method模式。

2.当有几个类包含几乎相同的算法，但有一些细微的差异时，可以使用此模式。





## 优点:

1.可以让客户端只覆盖大型算法的某些部分，从而减少算法其他部分发生的更改对它们的影响。

2.可以将重复的代码拖放到超类中。



## Demo

```java
public class TemplateMethodTest03 {


    public static void main(String[] args) {
        SubClass subClass = new SubClass();
        subClass.operaton();
    }
    
}

abstract class AbstractClass {

    public void operaton() {
        System.out.println("pre...");

        System.out.println("step1 ");

        System.out.println("step2 ");

        templateMethod();

    }

    /**
     * 自定义方法
     */
    abstract protected void templateMethod();

}

class SubClass extends AbstractClass {

    /**
     * 自定义方法
     */
    @Override
    protected void templateMethod() {
        System.out.println("我是: " + this.getClass().getSimpleName());
    }
}

```





钩子例1:

```java
abstract class AbstractClass {
  
  final void templateMethod() {
    primitiveOperation1();
    primitiveOperation2();
    concreteOperation();
    hook();
  }
  
  /**
   * 抽象方法，由具体的子类实现
   */
  abstract void primitiveOperation1(); 
  
  /**
   * 抽象方法，由具体的子类实现
   */
  abstract void primitiveOperation2();
  
  final void concreteOperation() {
    // 方法实现
  }
  
  /**
   * 具体的方法，但它什么事都不做，我们称这种默认不做事的方法为钩子(hook).
   * 子类可以视情况决定要不要覆盖他们
   */
  void hook() {} 
  
}
```





钩子例2:

> 钩子能够作为条件控制，影响抽象类中的算法流程

```java
public abstract class CaffeineBeverageWithHook {
  
  void prepareRecipe() {
    boilWater();
    brew();
    pourInCup();
    
    /**
     * 我们这里加上了一个条件语句,而该条件是否成立，是由一个具体方法
     * customerWantsCondiments()决定的。
     */
    if (customerWantsCondiments()) {   
      addCondiments();
    }
  }
  
  abstract void brew();
  
  abstract void addCondiments();
  
  void boilwater() {
    System.out.println("Boiling water");
  }
  
  void pourInCup() {
    System.out.println("Pouring into cup");
  }
  
  /**
   * 我们在这里定义了一个方法,(通常)是空的缺省实现。
   * 这个方法只会返回true，不做别的事。
   * 这就是一个钩子，子类可以覆盖这个方法，但不见得一定要这么做
   */
  boolean customerWantsCondiments() {
    return true;
  }
}
```

