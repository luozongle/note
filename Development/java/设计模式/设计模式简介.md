

设计模式的七大原则

### 1. 开闭原则/开放-封闭原则(Open Close Principle)
开闭原则的意思是:对扩展开放，对修改关闭。在程序需要进行扩展的时候，不能去修改原有的代码，实现一个热插拔的效果。简而言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。

但是绝对的对修改关闭是不可能的。无论模块多么的"封闭"，都会存在一些无法对之封闭的变化。既然不可能完全封闭，我们设计的模块应该对哪种变化封闭做出选择。我们必须先猜测出最有可能发生变化的种类，然后构造抽象来隔离那些变化。

我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化等待的时间越长，要创建正确的抽象就越困难。

开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做抽象，然后，对应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。



### 2. 里氏代换原则(Liskov Substitution Principle)
里氏代换原则是面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当派生类可以代替掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类上增加新的行为。里氏替换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。

简单讲就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，把父类都替换成它的子类，程序的行为没有变化，简单的说，子类型必须能够替换掉它们的父类型。

正是因为有了这个原则，使得继承复用成为了可能，只有当子类可以代替掉父类，软件单位的功能不受影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。



### 3. 依赖倒转原则(Dependence Inversion Principle)
这个原则是开闭原则的基础，具体内容:针对接口编程，依赖于抽象而不依赖于具体

抽象不应该依赖细节，细节应该依赖于抽象

例:

比如我们开发了一个产品，不同的客户希望使用不同的数据库或存储信息的方式。如果业务代码依赖了具体的数据库那就比较麻烦了，所以我们更换数据库的时候不能影响业务代码才对。 所以不管高层模块还是底层模块，它们都应该依赖于抽象，具体一点就是接口或者抽象类，只要接口是稳定的，那么任何一个更改都不用担心其它受到影响。

依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象设计，反之那就是过程化的设计了。



### 4. 接口隔离原则(Interface Segregation Principle) 
这个原则的意思是:使用多个隔离的接口,比使用单个接口要好。它还有另外一个意思是:降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护软件设计思想，它强调降低依赖，降低耦合。



### 5. 迪米特法则,又称最少知道原则(Demeter Principle)
最少知道原则是指:一个实体应当尽量少地与其他实体类发生相互作用，使得系统功能模块相对独立



### 6. 合成复用原则(Composite Reuse Principle)
合成复用原则是指:尽量使用合成/汇聚的方式，而不是使用继承



### 7. 单一职责原则(Single Responsibility Principle)
单一职责原则表示一个模块的组成 元素之间的功能相关性。从软件变化的角度来看，就一个类而言，应该仅有一个让它变化的原因;通俗的讲,即一个类只负责一项职责。

如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。

软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。其实要去判断是否应该分离出类来，也不难，那就是如果我们能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。



SOLID原则:
- 单一职责原则(SRP)
- 开放封闭原则(OCP)
- 里氏替换原则(LSP)
- 接口隔离原则(ISP)
- 依赖倒置原则(DIP)









