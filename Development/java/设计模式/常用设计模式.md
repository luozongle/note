[TOC]

# 常用设计模式



## 单例模式



##### 简介: 

单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。



##### 基本实现思路:

单例对象要求能够返回对象一个引用(永远是同一个)和一个获得该实例的方法(必须是静态方法,通常使用getInstance这个名称)

单例的实现主要是通过以下两个步骤:

1. 将该类的构造方法定义为私有方法，这样其他处的代码就无法通过该类的构造方法来实例化对象。
2. 在该类中提供一个静态方法，当我们调用这个方法给我们返回这个对象。



### 1.懒汉模式:
特点:延迟加载，只有真正使用的时候，才开始实例化
1) 线程安全问题
2) double check 加锁优化
3) 编译器(JIT)，CPU有可能对指令进行重排序，导致使用到尚未初始化的实例，可以通过添加volatile关键字进行修饰



注意:

一定要加volatile，因为初始化代码的时候 `instance = new LazySingleton();`这一步可以分解成下面三个步骤
1. 分配内存空间
2. 初始化对象
3. 将对象指向刚分配的内存空间



如果不加volatile单线程下没有什么问题，但是多线程下就可能发生

| Time | Thread A                  | Thread B                                                     |
| ---- | ------------------------- | ------------------------------------------------------------ |
| T1   | 检查到对象obj为空         |                                                              |
| T2   | 获取类的同步锁            |                                                              |
| T3   | 再次检查到obj为空         |                                                              |
| T4   | 为obj分配内存空间         |                                                              |
| T5   | 将obj指向刚分配的内存空间 |                                                              |
| T6   |                           | 检查到对象obj不为空                                          |
| T7   |                           | 访问并返回obj(此时对象还未初始化，得到一个初始化未完成的对象) |
| T8   | 初始化obj                 |                                                              |

T7时刻线程B对obj的访问，访问的是一个初始化未完成的对象，发生错误。

加了volatile后会禁止指令重拍，就不会有这个问题了。

例:

```java
class LazySingleton {

    private volatile static LazySingleton instance;

    private LazySingleton () {}

    public static LazySingleton getInstance() {
        if (instance == null) {
            synchronized (LazySingleton.class) {
                if (instance == null) {
                    //noinspection InstantiationOfUtilityClass
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }
}
```




### 2. 饿汉模式
类加载的初始化阶段就完成了实例的初始化。本质上就是借助于JVM类加载机制，保证实例的唯一值(初始化过程只会执行一次)及线程安全(JVM以同步的形式来完成类加载的整个过程)。

类加载过程

1.加载二进制数据到内存中，生成对应的Class数据结构

2.连接: a.验证，b.准备(给类的静态成员变量赋默认值)，c.解析

3.初始化:给类的静态变量赋初始值

只有真正使用对应的类时，才会触发初始化 如(直接进行new 操作，访问静态属性、访问静态方法，用反射访问类，初始化一个类的子类等)





```java
class HungrySingleton {

    @SuppressWarnings("InstantiationOfUtilityClass")
    private static final HungrySingleton instance = new HungrySingleton();

    private HungrySingleton() {}

    public static HungrySingleton getInstance() {
        return instance;
    }

}
```



### 3.静态内部类

1.本质上是利用类的加载机制来保证线程安全。

2.只有在实际使用的时候，才会触发类的初始化，所以也是懒加载的一种形式。

```java
class InnerClassSingleton {

    private static class InnerClassHolder {
        @SuppressWarnings("InstantiationOfUtilityClass")
        private static final InnerClassSingleton instance = new InnerClassSingleton();
    }

    private InnerClassSingleton() {
        //noinspection ConstantConditions
        if (InnerClassHolder.instance != null) {
            throw new RuntimeException("单例不允许多个实例");
        }
    }

    public static InnerClassSingleton getInstance() {
        return InnerClassHolder.instance;
    }

}
```



### 4.





## 模板模式











































