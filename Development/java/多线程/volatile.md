[TOC]



### 什么是JMM模型?

​	Java内存模型(Java Memory Model简称JMM)是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段，静态字段和构成数组对象的元素)的访问方式。JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。





### JMM不同于JVM内存区域模型

​	JMM与JVM内存区域的划分是不同的概念层次，更恰当的说JMM描述的是一组规则，通过这组规则控制程序各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性，有序性、可见性展开。JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。



### 主内存

​	主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称为局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发生线程安全问题



### 数据同步八大原子操作
(1) lock(锁定): 作用于主内存的变量，把一个变量标记为一条线程独占状态
(2) unlock(解锁): 作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
(3) read(读取): 作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
(4) load(载入): 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
(5) use(使用):作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
(6) assign(赋值):作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量
(7) store(存储):作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
(8) write(写入):作用于工作内存的变量,它把store操作从工作内存中的一个变量值传送到主内存的变量中

如果要把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。但是Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。





### 同步规则分析

1) 不允许一个线程无原因地(没有发生过任何assign操作)把数据从工作内存同步回主内存中
2) 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load或者assign)的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。
3) 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会解锁。lock和unlock操作必须成对出现。
4) 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新load或assign操作初始化变量的值
5) 如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量
6) 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中(执行store或write操作)




### 原子性
	原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。

### 可见性
	可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改过的新值。
	但是多线程环境中就不一定了，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回主内存中的，这就可能存在一个线程A修改了共享变量X的值，还未写回主内存时，另一个线程B又对主内存中同一个共享变量X进行操作，但此时A线程工作内存中共享变量X对线程B来说并不可见，这种工作内存与主内存同步延迟现象造成了可见性问题，另外指令重拍以及编译器优化也可能导致可见性问题，无论是编译器优化还是处理器优化的重拍现象，在多线程环境下，确实会导致程序轮序执行的问题，从而也就导致可见性问题。

### 有序性
	有序性是指对于单线程的执行代码，我们总是认为代码的执行是按照顺序依次执行的，这样的理解没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重拍现象，重拍后的指令与原指令的顺序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。


​	
### as-if-serial语义
	as-if-serial语义的意思是:不管怎重排序(编译器和处理器为了提高并行度),(单线程)程序的执行结果不能被改变。编译器、runtime和处理器都必须遵循as-if-serial语义。
	为了遵循as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。


​	
### happens-before 原则
	只靠sychronized和volatile关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，从JDK5开始，Java使用新的JSR-133内存模型，提供了happens-before原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据。


​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	















