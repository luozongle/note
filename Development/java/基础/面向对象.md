疑惑?

- OOP是什么
- 为什么要封装
- SOLID设计原则
- LSP原则



类的概念

- 封装:



类的设计技巧:

1. 一定要保证数据私有

   这是最重要的，绝对不要破坏封装性。有时候，需要编写一个访问器或更改器方法，但最好还是保持实例域的私有性。数据的表示形式很可能会发生变化，但他们的使用方式却不会经常发生变化。当数据保持私有时，它们的表示形式的变化不会对类的使用者产生影响，即使出现bug也易于检测。

2. 一定要对数据初始化

3. 不要在类中使用过多的基本类型

   就是说，用其他的类代替多个相关的基本类型的使用。

4. 不是所有的域都需要独立的域访问器和域更改器

5. 将职责过多的类进行分解

6. 类名和方法名要能够体现它们的职责

7. 优先使用不可变的类



Java用于控制可见性的4个访问修饰符

- private 仅对本类可见
- default (不需要修饰) 对本包可见
- protected 对本包和子类可见
- public 对所有类可见



equals与==的区别

需要从基本类型与引用类型分别描述

- 基本类型

  基本类型包括`byte、short、int、long、double、folat、boolean、char`

  对于基本类型来说，==是直接对其值进行比较

- 引用类型

  对于引用类型的变量来说，比较的是两个变量是否指向同一个引用(对其内存地址进行比较)

equals是Object的一个方法，任何类都继承了Object类，如果没有重写equals，equals方法里是直接调用的==，因此实际上与==没有差别，但是equals方法不能用于基本数据类型的比较，因为基本数据类型非对象。  

Java语言规范要求equals方法具有下面的特性:
1. 自反性:对于任何非空引用x，x.equals(x)应该返回true
2. 对称性:对于任何引用x和y，而且仅当y.equals(x)返回true，x.equals(y)也应该返回true
3. 传递性:对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true
4. 一致性:如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果
5. 对于任意非空引用x，x.equals(null)应该返回false

  



Java重写(Override)与重载(Overload)

重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。

重写规则:

- 参数列表与被重写方法的参数列表必须完全相同
- 返回类型与被重写的返回类型可以不相同，但是必须是父类返回值的派生类
- 访问修饰符不能比父类中被重写的方法的访问权限更低。
- 父类的成员方法只能被它的子类重写
- 声明为final的方法不能被重写(final类不能被继承，并且如果类被声明为final,则里面的方法都会被自动声明为final,但是属性不会被自动声明为final)
- 声明为static的方法不能被重写，但是能够被再次声明
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法
- 重写的方法能够抛出任何非检查异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的检查异常，或者比被重写方法声明的更广泛的检查异常，反之则可以。
- 构造方法不能被重写
- 如果不能继承一个类，则不能重写该类的方法



重载是在一个类里面，方法名字相同，而参数不同。返回值类型也可以不同

每个重载的方法(或者构造函数)都必须有一个独一无二的参数类型列表。

重载规则:

- 被重载的方法必须改变参数列表(参数个数或类型不一样)
- 被重载的方法可以改变返回类型
- 被重载的方法可以改变访问修饰符
- 方法能够在同一个类中或者一个子类中被重载
- 无法以返回值类型作为重载函数的区分标准



抽象类

抽象类可以包含抽象方法、具体数据和具体方法。抽象类不能被实例化。

抽象方法充当着占位的角色，他们的具体实现在子类中。扩展抽象类可以有两种选择，一种是在抽象类中定义部分抽象方法或不定义抽象方法，这样就必须将子类也标记为抽象类，另一种是定义全部的抽象方法，这样一来子类就不是抽象的了。



继承的设计技巧

1. 将公共操作和域放在超类
2. 不要直接使用受保护的域
3. 使用继承实现"is-a"关系
4. 除非所有继承的方法都有意义，否则不要使用继承
5. 在覆盖方法时，不要改变预期的行为
6. 使用多态，而非类型信息
7. 不要过多地使用反射





接口

在Java程序语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。

- 接口中所有的方法自动属于public
- 接口中不能包含实例域或静态方法(java8允许静态方法?)
- 接口中可以包含常量，所有的域被自动设置为public static final
- 接口中可以包含默认方法(这些方法不能引用实例域)



接口与抽象类，已经有了抽象类了，为什么Java程序语言还要引入接口的概念

1. 每个类只能扩展与一个类，但是可以实现多个接口
2. 接口












泛型















